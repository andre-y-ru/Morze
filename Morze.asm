     ;--- Morze ---
       .386
      .model flat, stdcall   ;плоская модель данных
      option casemap :none   ;дает указание компилятору неразличать прописные и строчные символы
      
      ;подключаем необходимые библиотеки и описания их структур и функций
      ;---------------------------------------------------------------------------
      include \masm32\include\windows.inc
      include \masm32\macros\macros.asm        ;подключаем макросредства
      include \masm32\include\user32.inc
      include \masm32\include\kernel32.inc
      include \masm32\include\msvcrt.inc
 
      includelib \masm32\lib\user32.lib
      includelib \masm32\lib\kernel32.lib
      includelib \masm32\lib\msvcrt.lib
      ;---------------------------------------------------------------------------
 
.data                             ; данные
point_delay     dd      110       ; длительность звука "точка" 
dash_delay      dd      360       ; длительность звука "тире" 
point db '*', NULL  ; звездочка - резервирование памяти для данных размером 1 байт (используем макросредства)
dash  db '-', NULL  ; тере - резервирование памяти для данных размером 1 байт (используем макросредства)
space db ' ', NULL  ; пробел (пустота) - резервирование памяти для данных размером 1 байт (используем макросредства)
morse   label   byte            ; таблица преобразования символов в код морзе (1 - точка, 2 - тире)
        db      'a', 1, 2, 0     ; резервирование памяти для данных размером 1 байт
        db      'b', 2, 1, 1, 1, 0
        db      'c', 2, 1, 2, 1, 0
        db      'd', 2, 1, 1, 0
        db      'e', 1, 0
        db      'f', 1, 1, 2, 1, 0
        db      'g', 2, 2, 1, 0
        db      'h', 1, 1, 1, 1, 0
        db      'i', 1, 1, 0
        db      'j', 1, 2, 2, 2, 0
        db      'k', 2, 1, 2, 0
        db      'l', 1, 2, 1, 1, 0
        db      'm', 2, 2, 0
        db      'n', 2, 1, 0
        db      'o', 2, 2, 2, 0
        db      'p', 1, 2, 2, 1, 0
        db      'q', 2, 2, 1, 2, 0
        db      'r', 1, 2, 1, 0
        db      's', 1, 1, 1, 0
        db      't', 2, 0
        db      'u', 1, 1, 2, 0
        db      'v', 1, 1, 1, 2, 0
        db      'w', 1, 2, 2, 0
        db      'x', 2, 1, 1, 2, 0
        db      'y', 2, 1, 2, 2, 0
        db      'z', 2, 2, 1, 1, 0
 
        db      '1', 1, 2, 2, 2, 2, 0
        db      '2', 1, 1, 2, 2, 2, 0
        db      '3', 1, 1, 1, 2, 2, 0
        db      '4', 1, 1, 1, 1, 2, 0
        db      '5', 1, 1, 1, 1, 1, 0
        db      '6', 2, 1, 1, 1, 1, 0
        db      '7', 2, 2, 1, 1, 1, 0
        db      '8', 2, 2, 2, 1, 1, 0
        db      '9', 2, 2, 2, 2, 1, 0
        db      '0', 2, 2, 2, 2, 2, 0
 
tab_length      dd      $ - offset morse        ; длина таблицы в байтах - текущее смещение минус адрес начала таблицы
 
.code  ; основной код программы 
wait_key proc   ; процедура ожидания нажатия клавиши от пользователя
    invoke FlushConsoleInputBuffer, rv(GetStdHandle,STD_INPUT_HANDLE) ; вывод текста в консоли
  @@:
    call crt__kbhit ; возвращает значение 0, если в буфере клавиатуры нет символов, и 1, если буфер не пуст
    test eax, eax   ;  сравнение ноль/не ноль
    jz @B           ; если @B = 0, то обходим рекурсивную ветвь
    call crt__getch ; берем искомый символ с консоли
    ret             ; возврат из процедуры
wait_key endp       ; ожидание нажатия клавиши  
 
 Main proc          ; вызов основной программы
   LOCAL hOutPut          :DWORD  ; буффер(хэндл) для ввода
   LOCAL nWriten          :DWORD  ; напечатано байт
 
invoke GetStdHandle, STD_OUTPUT_HANDLE ; получаем хэндл консоли для вывода
mov hOutPut, eax                       ; получаем хэндл для вывода
 
_loop:                                 ; организация цикла
 call wait_key                         ; вызываем подпрограмму
 cmp     eax, 27         ; ESC ?
 jz      EXIT            ; если да - выходим
 cmp     eax, ' '        ; сравниваем
 jz      _space          ; если пробел = 0, то
 mov     ecx, tab_length ; размер таблицы
 lea     edi, morse               ; загружаем адрес таблицы в регистр di

 repne   scasb           ; ищем в таблице символ набранный с клавиатуры
 jnz     _loop           ; символ не найден
 mov     esi, edi        ; si = di - позиция в таблице найденого символа
_out_morseCode:          ; на следующий символ в таблице
        invoke   Sleep, point_delay ; устанавливаем паузу 
        lodsb                   ; загружаем цифру из таблицы
        cmp     al, 1           ; сравниваем цифра 1?
        jz      _point          ; значит выводим точку
        cmp     al, 2           ; сравниваем цифра 2?
        jz      _dash           ; выводим тире
        or      al, al          ; цифра 0? - операция поразрядное «или» выполняет логическое сложение всех пар бит операндов
        jz      _loop           ; дошли до конца строки
        jmp     _loop           ; на эту строку перейдем только если есть ошибка в таблице
_point:                         ; используем макросредства
        
        invoke WriteConsole, hOutPut, addr point, 1, addr nWriten,NULL ; устанавливаем паузу соответствующую точке
        
        invoke   Beep, 1000, point_delay ; пищим
        jmp     _out_morseCode           ; на следующий символ в таблице
_dash:
        invoke WriteConsole, hOutPut, addr dash, 1, addr nWriten,NULL ; устанавливаем паузу соответствующую точке
 
        
        invoke   Beep, 1000, dash_delay ; воспроизводим звук
        jmp     _out_morseCode  ; на следующий символ в таблице
_space:
        invoke WriteConsole, hOutPut, addr space, 1, addr nWriten,NULL ; устанавливаем паузу соответствующую точке
        jmp     _loop    ; на эту строку перейдем только если есть ошибка в таблице                                  

EXIT:                 ; остановить ассемблирование текущего файла
invoke Sleep, 20      ; ждем ответ пока не пройдет таймаут
invoke ExitProcess,0  ; продолжить выполнение программы далее
 
Main endp             ; конец главной процедуры
end Main              ; конец программы